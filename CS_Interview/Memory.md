# 메모리 (메모리 계층, 웹 브라우저의 캐시, 가상 메모리, 메모리 할당을 포함하여)

이전 시간에 메모리에 대해서 설명을 했습니다.
간략하게 정리를 하자면 레지스터 > 캐시메모리(SRAM) > 메인메모리(DRAM) > 하드디스크(HDD)입니다.
잘 기억이 안 나신다면 아래의 링크를 통해 다시 복습하시면 좋을거 같습니다.
[메모리](https://github.com/uiseongsang/CS_Study/blob/main2/CS_Interview/운영%20체제%20(CPU%2C%20RAM%2C%20GPU%2C%20메모리).md#메모리)

## 메모리 계층
<img width="668" alt="image" src="https://github.com/uiseongsang/CS_Study/assets/40707686/b79936bc-d03b-411b-81c1-28fe767d8644">

여기서 캐시를 좀 더 세분화를 하면

<img width="442" alt="image" src="https://github.com/uiseongsang/CS_Study/assets/40707686/47b2ca5f-9f06-4e9c-a9f7-823ceba26265">

L1은 L2,L3와 다르게 CPU안에 Memory Unit에 있다.

<img width="288" alt="image" src="https://github.com/uiseongsang/CS_Study/assets/40707686/21e755c8-313b-4dfd-b01e-3006b6277803">

L2,L3 캐시메모리는 메인 메모리에 있는 데이터를 캐시 메모리에 불러오고, CPU가 필요한 데이터를 캐시에서 먼저 찾도록 하여 시스템 성능을 향상시켜줍니다.

### 캐시메모리(L2,L3) VS CPU 레지스터
* 캐시메모리(L2,L3)는 CPU와 별도 공간이며, 메인 메모리와 CPU 간의 속도차이를 극복하기 위한 것
* CPU 레지스터는 CPU안에서 연산을 처리하는 데이터 저장 공간

## 웹 브라우저의 캐시
서버 지연을 줄이기 위해 웹 페이지(HTML,CSS,JS), 이미지등 웹 문서들을 임시 저장하기 위한 기술이다.

### 웹 브라우저 캐시의 종료
1. Browser Caches
* 브라우저 또는 HTTP 요청을 하는 클라이언트 애플리케이션에 의해 내부 디스크에 캐시
* Cache된 Resource를 공유하지 않는 한 개인에 한정된 Cache
* 이미 방문한 페이지를 재 방문시 요청이 사용

2. Proxy Caches
* Browser Cache와 동일한 원리로 동작하며 Client나 Server가 아닌 네트워크 상에서 동작
* 큰 회사나 IPS의 방화벽에 설치 되며 대기시간 & 트래픽 감소, 접근정책 & 제한 우회, 사용률 기록등 수행
* 한정된 수의 클라이언트을 위하여 무한대의 웹서버의 컨텐츠를 캐시
  
3. Gateway Caches
* 서버 앞 단에 설치되어 요청에 대한 캐시 및 효율적인 분배를 통해 가용성, 신뢰성, 성능등을 향상
* Encryption / SSL acceleration, Load balancing, Server/cache static content등을 수행
* 무한대의 클라이언트들에게 한정된 수의 웹서버 컨텐츠를 제공

### 장단점
장점: 브라우징 속도를 향상시킨다

단점: 업데이트된 파일을 만료되지 않은 캐시 떄문에 새로 받아오지 않아 문제가 발생할 수 있다

-> 캐시의 만료기간은 웹사이트에 의해 결정

-> 문제가 생길시 브라우저 캐시를 모두 삭제

## 가상 메모리
메모리가 실제 메모리보다 많아 보이게 하는 기술로, 어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 실행이 가능하다
-> 애플리케이션이 실행될 떄, 실행에 필요한 부분만 메모리에 올라가며 나머지는 디스크로 간다. 즉, 디스크가 RAM처럼 작동(메모리가 작고 빠른 RAM이랑 메모리가 크고 느린 디스크와 병합)

가상 메모리를 구현하기 위해서는 컴퓨터가 특수 메모리 관리 하드웨어를 갖추고 있어야함 -> MMU(Memory Management Unit)

### MMU(Memory Management Unit)
* MMU는 가상주소를 물리주소로 변환하고, 메모리를 보호하는 기능을 수행
* MMU를 사용하게 되면, CPU가 각 메모리에 접근하기 이전에 메모리 주소 번역 작업이 수행
* 메모리를 가상 주소 -> 물리적 주소로 번역시 작업 부하가 높아지므로, MMU는 RAM을 여러 부분(페이지 Pages)로 나누어 각 페이지를 하나의 독립된 항목으로 처리
* 페이지 및 주소 번역 정보를 기억하는 작업이 가상 메모리를 구현하는 데 있어 결정적인 절차이다


## 메모리 할당
연속할당 방식과 불연속할당 방식이 있다.

### 연속 할당 방식
프로세스를 메모리에 올릴 때 해당 주소 공간을 여러개로 분할하지 않고 물리적 메모리의 한 곳에 연속적으로 정재하는 방식

연속할당 방식에는 크게 고정분할 방식솨 가변분할 방식이 있다.

#### 고정분할 방식
물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어두고 각 분할에 하나의 프로세스를 적재해 실행

-> 외부 단편화와 내부 단편화가 발생할 수 있다

외부 단편화: 프로그램의 크기보다 분할의 크기가 작은 경우에는 해당 분할이 비어 있는데도 불구하고 프로그램을 적재하지 못하기에 발생하는 현상

![image](https://github.com/uiseongsang/CS_Study/assets/40707686/e1686b00-840f-4f4d-908e-6a8361641ab7)



내부 단편화: 프로그램이 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남는 현상

![image](https://github.com/uiseongsang/CS_Study/assets/40707686/9807409b-d2b8-46d7-abdc-23968e80caf3)


#### 가변분할 방식
메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식

![image](https://github.com/uiseongsang/CS_Study/assets/40707686/d6417375-630a-4522-bade-77cc5c16f4a4)

> 프로그램의 크기에 맞게 할당하기 떄문에 내부단편화는 발생하지 않는다.

### 불연속 할당 방식
프로그램이 메모리의 여러 영역에 분산되어 올라갈 수 있는 방식

> 대표적인 예로 페이징과 세그먼테이션 기법

#### 페이징 기법
일정한 크기로 잘라서 메모리에 할당

* 외부 단편화가 발생하지 않는다
  
-> 디스크에서 들고오는 페이지들의 크기가 프레임보다 큰 경우가 없기 떄문에 메모리에 못들어가는 경우는 없다

* 내부 단편화가 생길 수 있다
  
-> 프로세스의 주소 공간 중 제일 마지막에 위치한 페이지에서는 내부단편화가 발생할 가능성이 있다.

#### 세그먼테이션 기법
프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치. 즉 각각의 세그먼트들은 동일한 크기를 갖지 않는다

논리적인 영역 = 세그먼트

* 외부 단편화가 발생한다
  
-> 세그먼트들 사이에는 작은 빈틈들이 여러곳에 생길 수 있는데, 그 작은 틈보다 큰 세그먼트가 메모리에 들어올려고 시도하면 들어갈 수 없다

* 내부 단편화는 발생하지 않는다 

참고자료:

https://ahnanne.tistory.com/15

https://baebalja.tistory.com/416

https://baebalja.tistory.com/428
